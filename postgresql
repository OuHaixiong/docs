CentOS 7 默认系统安装Postgresql： (最好不要系统自带的，版本太低，有些功能不支持)
1，yum install -y postgresql-server postgresql postgresql-contrib
2，初始化：postgresql-setup initdb
3，重启：systemctl restart[start/stop] postgresql.service
4，登录后进行修改密码，postgres的默认密码为空   （貌似修改了密码没有什么用，原因是因为没有设置pg_hba.conf中登录的ip和用户需要用密码进行登录）
# sudo su - postgres 切换postgres用户
-bash-4.2$ psql 切换成执行sql控制体 【psql (9.2.23)】
postgres=# alter user postgres password '123456';
\q :退出
exit ：退出用户
5，重启后，可查看端口：netstat -tunlp |grep 5432
6，使用上面的步骤登录后，创建用户：postgres=# create user ybapi with password '123456';
7，创建数据库，并指定拥有者：postgres=# create database ybapi owner ybapi;
8，给数据库赋权：postgres=# grant all privileges on database ybapi to ybapi;
9，退出postgres用户，并用ybapi用户进行登录：
    postgres=# \q
	-bash-4.2$ psql -U ybapi -d ybapi -h 127.0.0.1 -p 5432 -W  （登入其他用户时一定要退出postgres用户后再来登录）
	如果输入密码后，仍然无法登录且提示：
	psql: FATAL:  Ident authentication failed for user "ybapi"
	需要修改配置：vim /var/lib/pgsql/data/pg_hba.conf，
	把：   host    all             all             127.0.0.1/32           ident
	改为： host    all             all             127.0.0.1/32            md5
	然后重启postgresql
10，登录成功后会显示：ybapi=>   这样就可以执行sql语句了	


配置文件在：vim /var/lib/pgsql/data/pg_hba.conf 如果需要所有的ip都能访问的话，加入如下一行：
host all all 0.0.0.0/0 md5 （CONNECTIONTYPE DATABASE USER ADDRESS METHDO md5即用密码认证身份登录）
还需要修改：/var/lib/pgsql/data/postgresql.conf
listen_addresses = '*' 监听地址 （默认只能本机访问： listen_addresses = 'localhost'）
postgresql.conf文件中涉及诸如：最大连接数、监听地址，监听端口、日志、内存、硬盘等等各种设置

假如允允许10.1.1.0~10.1.1.255网段登录数据库：
host    all    all    10.1.1.0/24    md5

安装目录/var/lib/pgsql及目录下文件或文件夹的可读、可写、可操作统统只开放给用户postgres

在终端输入psql命令时，常常会遇到下面这个错。这个错有两个解决方式：
1）    重启postgresql服务。
2）    删掉/usr/local/var/postgres/postmaster.pid文件。
       psql: could not connect to server: No such file or directory
       Is the server running locally and accepting
       connections on Unix domain socket "/tmp/.s.PGSQL.5432"?

下面在centos7 安装postgresql10
1，更新源，访问https://yum.postgresql.org/repopackages.php找到Available Repository RPMs -> PostgreSQL 10 -> CentOS 7 - x86_64 右键复制链接地址
2，执行 yum install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm -y
3，先查看postgresql源：yum list |grep postgresql 找到要安装的源
4，执行：yum install -y postgresql10.x86_64 postgresql10-devel.x86_64 postgresql10-server.x86_64 postgresql10-contrib.x86_64
5，初始化：/usr/pgsql-10/bin/postgresql-10-setup initdb
6，启动数据库并设置开机启动
    sudo systemctl start postgresql-10
    sudo systemctl enable postgresql-10.service
7，登录postgresql并设置密码:
    # su - postgres
    -bash-4.2$ psql
    postgres=# ALTER USER postgres WITH PASSWORD '123456';
    退出：\q
8，默认情况下postgresql是不用密码不支持远程登录的。我们要用密码登录，需要修改配置文件：vim /var/lib/pgsql/10/data/pg_hba.conf
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     peer
# IPv4 local connections:
host    all             all             127.0.0.1/32            ident
# IPv6 local connections:
host    all             all             ::1/128                 ident
# Allow replication connections from localhost, by a user with the
# replication privilege.
local   replication     all                                     peer
host    replication     all             127.0.0.1/32            ident
host    replication     all             ::1/128                 ident
改成：
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" is for Unix domain socket connections only
local   all             all                                     md5
# IPv4 local connections:
host    all             all             127.0.0.1/32            md5
# IPv6 local connections:
host    all             all             ::1/128                 md5
# Allow replication connections from localhost, by a user with the
# replication privilege.
#local   replication     all                                     peer
#host    replication     all             127.0.0.1/32            ident
#host    replication     all             ::1/128                 ident
host      all            all             0.0.0.0/0               md5
    修改远程访问：vim /var/lib/pgsql/10/data/postgresql.conf
    #listen_addresses = 'localhost'
    #port = 5432
    改成：
    listen_addresses = '*'
    port = 5432
9，修改配置后需要重启：systemctl restart postgresql-10
10，可以使用刚才更改过密码的账号登录了
    # su - postgres
    -bash-4.2$ psql -U postgres -h 127.0.0.1 -p 5432 -W    成功后显示： psql (9.2.23, server 10.5)  ->   postgres=#
11，  创建用户：create user ybapi with password '123456';
12， 创建数据库，并指定拥有者：postgres=# create database ybapi owner ybapi;
13， 给数据库赋权：postgres=# grant all privileges on database ybapi to ybapi;
14， 退出postgres用户，并用ybapi用户进行登录：
    postgres=# \q
    -bash-4.2$ psql -U ybapi -d ybapi -h 127.0.0.1 -p 5432 -W
15，执行sql语句：
    drop table if exists uploadfile;
    create table uploadfile (
      id bigserial,
      rid varchar(64) not null,
      appid varchar(32) not null,
      hash varchar(64) not null,
      size int4 default 0,
      path varchar(256) not null,
      width int4 default 0,
      height int4 default 0,
      duration int4 default 0,
      extinfo jsonb,
      create_time int4 default 0,
      update_time int4 default 0,
      money NUMERIC(20, 2) default 0.00, // 全部20位，小数点后2位
      primary key(id)
    );

    


安装目录：/usr/pgsql-10
数据目录：/var/lib/pgsql/10/data

如下是创建字段时，相等的语句：
real == float4
bigserial == int8 DEFAULT nextval('admin_action_id_seq'::regclass) NOT NULL 自增int8型


命令行：
1, 删除表：drop table if exists admin_user; 或 drop table admin_action; // 删除表后，或同时把自增id表（admin_action_id_seq）给删除
2, 增加一列 ：alter table table_name add column_name datatype;alter table feedback add column type smallint default 1;
3, 删除一列：alter table table_name drop column_name; alter table business drop artificial_person;
4, 更改列的数据类型: ALTER TABLE table_name ALTER  column_name TYPE datatype; 如果有数据或数据类型不匹配时，基本是修改不成功的
                    ALTER TABLE product ALTER  descimgs TYPE jsonb USING descimgs::jsonb[]; 
5, 表重命名：ALTER TABLE table_name RENAME TO new_name;
6, 更改列的名字：ALTER TABLE table_name RENAME column_name to new_column_name;
7, 字段的not null设置：ALTER TABLE table_name ALTER column_name {SET|DROP} NOT NULL;
8, 给列添加default：ALTER TABLE table_name ALTER column_name SET DEFAULT expression;
9, 修改主键id的自增值从某个值开始:alter sequence business_id_seq restart with 600002;
10, 查询：select * from product where title='小米8' 特别注意这里，如果是字符型字段，不能用双引号(")，只能用单引号(')
11, \q ：退出
12, \l : 列出所有库
13, \du: 列出所有用户
14, \d : 列出库下所有表     (\dt:查看所有表，\d tableName: 查看表结构)
15, 创建索引：create unique index user_id_index on admin_user_action using btree("admin_user_id", "xxx"); // unique index:唯一索引；index：普通索引
16, 备份数据库表结构和数据：/usr/pgsql-10/bin/pg_dump -h 127.0.0.1 -p 5432 -U postgres ybapi > /data/ybapi.sql  使用pg_dumpall可以备份本地所有库
17, 恢复数据库： /usr/bin/psql -h127.0.0.1 -p 5432 -U postgres -d abc < /data/abc.sql   -d：数据库名称
18, 删除数据库：postgres=# drop database abc; // 如果有用户打开了数据库，是无法删除的
19, 删除用户：postgres=# drop role devops; // 如果该用户还拥有数据库，是无法删除该用户的，需要先删除数据库后，才能删除该用户
20, 创建用户：postgres=# create user root with password '123456';
21, 创建数据库并指定所有者：postgres=# create database testdb owner root;
22, 登录数据库：-bash-4.2$ psql -h127.0.0.1 -p5432 -Uroot -dtestdb
23, 修改主键id的自增值从某个值开始：alter sequence business_id_seq restart with 600002;
24, 备份指定表结构和数据： /usr/bin/pg_dump -U root testdb -t tb1  > /data/testdb_tb1.sql // 只能备份单表
25, 备份多个表：/usr/bin/pg_dump -U root testdb -t tb1 -t admin_action  > /data/testdb_tbs.sql
26, 查找邀请人大于100的所有用户列表：select * from ( select user_id, count(user_id) num from invite where type=0 group by user_id) as i where i.num>99 order by i.num desc;
27, 从更新的多条数据是从另一张表里来的：UPDATE sphinx_counter SET (min_id, max_id) = (select MIN(id), MAX(id) from product) where table_name='product'
28, 从别的表中插入多条数据：INSERT INTO sphinx_counter (table_name, min_id, max_id) VALUES ('product', (select MIN(id) from product), (select MAX(id) from product))
29, 时间戳字符串转整型：select (date_part('epoch',CURRENT_TIMESTAMP))::bigint
30，多条记录更新，并加入时间戳 ： UPDATE sphinx_counter SET (min_id, max_id, update_time) = (select MIN(id), MAX(id), (date_part('epoch', CURRENT_TIMESTAMP))::bigint from product)  where table_name='product'
31，导入sql文件： psql -h localhost -d databaseName -U username -f /xxx/xxx/xx.sql
32，删除索引：drop index product_recommend_type_idx;
33，修改用户密码：alter user root with password '123456';


一、日期格式转换

1.字符日期格式转化为UNIX时间戳格式

字段endtime为内容为UNIX时间戳格式，例如1346650755

select * from test where endtime >= extract(epoch FROM date('2012-09-03 00:00:00'));

2.UNIX时间戳转化为字符日期格式

select * from test where date(to_timestamp(endtime))>='2012-09-02';



下面是字段的取值范围：
smallint[int2]            2 字节     小范围整数                                   -32768 到 +32767
integer[int4/int]         4 字节     常用的整数                                   -2147483648 到 +2147483647
bigint[int8]              8 字节     大范围的整数                              -9223372036854775808 到 9223372036854775807
decimal                   可变长      用户声明精度，精确                  小数点前 131072 位；小数点后 16383 位 （无限制）。 类型decimal和numeric是等效的
numeric                   可变长      用户声明精度，精确                  小数点前 131072 位；小数点后 16383 位 （无限制）。  建议将它用于货币金额和其它要求精确计算的场合（计算要慢很多）
real[float4]              4 字节     可变精度，不精确                       6位十进制数字精度
double precision[float8]  8 字节     可变精度，不精确                       15位十进制数字精度(浮点型数据)
smallserial               2 字节     自增的小范围整数                        1 到 32767
serial                    4 字节     自增整数                                       1 到 2147483647
bigserial                 8 字节     自增的大范围整数                        1 到 9223372036854775807




下面是数据库的事务隔离级别总结：set traansaction isolation level serializable; // 设置事务隔离级别

事务隔离级别分为：read uncommitted（读取未提交），read committed（读取已提交），repeatable read（可重复读），serializable（可串行化），级别从左到右依次递增 
postgresql默认事务隔离级别是read committed，且postgresql没有read uncommitted隔离级别
mysql默认事务隔离级别是repeatable read

脏读（dirty read）：当一个事务读取另一个事务尚未提交的修改时数据就叫脏读
非重复读（nonrepeatable read）：同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，如果每次返回不同的结果集，就叫非重复读。
幻像（phantom read）：同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，就叫幻像读。

postgresql如果一个事务内，未提交的数据，是可以马上读取出来的。如果不在一个事务内，不管读取的是事务涉及的表还是非事务涉及的表，均会等等事务执行完毕，才可进行读取，且不能读取未提交的数据。
经多次测试mysql也和postgresql一样，会阻塞请求，且没有测出脏读和不可重复读的情况。后经证实和框架有关，我用yii2进行测试的，yii2判断如果有事务在执行时，会阻塞所有的查询、更新、删除操作。


总结表格如下
Isolation level               Dirty read（脏读）                                  Non-repeatable read（不可重复读）                      Phantoms read（幻读）
Read Uncommitted              may occur（可能）                                       may occur                                 may occur
Read Committed                don't occur（不可能）                               may occur                                 may occur
Repeatable Read               don't occur                      don't occur                               may occur
Serializable                  don't occur                      don't occur                               don't occur

   